{"version":3,"sources":["../src/express/controllers/BaseController.ts"],"names":[],"mappings":";;;AACA,uEAAkE;AAClE,yCAAoC;AACpC,+DAA0D;AAI1D,MAAM,iBAAiB,GAAkD;IACrE,GAAG,CAAC,MAAuC,EAAE,CAAc,EAAE,CAAM;QAC/D,OAAO,CAAC,GAAY,EAAE,GAAa,EAAE,IAAkB,EAAE,EAAE;YACvD,IAAI,UAAU,GAAG,IAAI,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;YACtC,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;gBAC3D,IAAI,CAAC,CAAC,GAAG,YAAY,6BAAa,CAAC,EAAE;oBACjC,eAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;iBACrB;gBACD,IAAI,CAAC,GAAG,CAAC,CAAC;YACd,CAAC,CAAC,CAAC;QACP,CAAC,CAAA;IACL,CAAC;CACJ,CAAC;AAMF,SAAgB,UAAU,CAA2B,KAAyB;IAC1E,OAAO,IAAI,KAAK,CAAC,KAAK,EAAE,iBAAiB,CAAQ,CAAC;AACtD,CAAC;AAFD,gCAEC;AAED,MAAsB,cAAc;IAIhC,YAAY,OAAgB,EAAE,QAAkB;QAC5C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAC7B,CAAC;IAES,KAAK,CAAC,YAAY,CAAI,GAAW,EAAE,aAAiC,EAAE,WAAoB,KAAK;QACrG,IAAI,IAAI,GAAM,SAAS,CAAC;QACxB,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE;YACzC,IAAI,GAAG,MAAM,aAAa,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;SACxD;QACD,IAAI,QAAQ,IAAI,CAAC,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,IAAI,CAAC,EAAE;YACnD,MAAM,IAAI,qCAAiB,EAAE,CAAC;SACjC;QACD,OAAO,IAAI,CAAC;IAChB,CAAC;CACJ;AAnBD,wCAmBC","file":"BaseController.js","sourcesContent":["import {NextFunction, Request, Response} from \"express\";\nimport {NotFoundException} from \"../exceptions/NotFoundException\";\nimport {logger} from \"../../logger\";\nimport {HttpException} from \"../exceptions/HttpException\";\n\ndeclare type ControllerClass<T extends BaseController> = new (request: Request, response: Response) => T;\n\nconst controllerHandler: ProxyHandler<ControllerClass<BaseController>> = {\n    get(target: ControllerClass<BaseController>, p: PropertyKey, _: any): any {\n        return (req: Request, res: Response, next: NextFunction) => {\n            let controller = new target(req, res);\n            new Promise((resolve) => resolve(controller[p]())).catch(err => {\n                if (!(err instanceof HttpException)) {\n                    logger.error(err);\n                }\n                next(err);\n            });\n        }\n    }\n};\n\ntype RouteHandlerResolver<T extends BaseController> = {\n    readonly [P in keyof T]: (req: Request, res: Response) => any;\n}\n\nexport function controller<T extends BaseController>(kelas: ControllerClass<T>): RouteHandlerResolver<T> {\n    return new Proxy(kelas, controllerHandler) as any;\n}\n\nexport abstract class BaseController {\n    protected request: Request;\n    protected response: Response;\n\n    constructor(request: Request, response: Response) {\n        this.request = request;\n        this.response = response;\n    }\n\n    protected async resolveParam<T>(key: string, paramResolver: (key: string) => T, required: boolean = false) {\n        let data: T = undefined;\n        if (this.request.params.hasOwnProperty(key)) {\n            data = await paramResolver(this.request.params[key]);\n        }\n        if (required && (data === undefined || data === null)) {\n            throw new NotFoundException();\n        }\n        return data;\n    }\n}\n"]}