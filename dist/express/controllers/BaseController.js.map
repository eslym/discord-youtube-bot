{"version":3,"sources":["../src/express/controllers/BaseController.ts"],"names":[],"mappings":";;;AACA,uEAAkE;AAClE,yCAAoC;AACpC,+DAA0D;AAI1D,MAAM,iBAAiB,GAAkD;IACrE,GAAG,CAAC,MAAuC,EAAE,CAAc,EAAE,CAAM;QAC/D,OAAO,CAAC,GAAY,EAAE,GAAa,EAAE,IAAkB,EAAE,EAAE;YACvD,IAAI,UAAU,GAAG,IAAI,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;YACtC,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;gBAC3D,IAAI,CAAC,CAAC,GAAG,YAAY,6BAAa,CAAC,EAAE;oBACjC,eAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;iBACrB;gBACD,IAAI,CAAC,GAAG,CAAC,CAAC;YACd,CAAC,CAAC,CAAC;QACP,CAAC,CAAA;IACL,CAAC;CACJ,CAAC;AAMF,SAAgB,UAAU,CAA2B,KAAyB;IAC1E,OAAO,IAAI,KAAK,CAAC,KAAK,EAAE,iBAAiB,CAAQ,CAAC;AACtD,CAAC;AAFD,gCAEC;AAED,MAAsB,cAAc;IAIhC,YAAY,OAAgB,EAAE,QAAkB;QAC5C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAC7B,CAAC;IAES,KAAK,CAAC,YAAY,CAAI,GAAW,EAAE,aAAiC,EAAE,WAAoB,KAAK;QACrG,IAAI,IAAI,GAAM,SAAS,CAAC;QACxB,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE;YACzC,IAAI,GAAG,MAAM,aAAa,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;SACxD;QACD,IAAI,QAAQ,IAAI,CAAC,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,IAAI,CAAC,EAAE;YACnD,MAAM,IAAI,qCAAiB,EAAE,CAAC;SACjC;QACD,OAAO,IAAI,CAAC;IAChB,CAAC;CACJ;AAnBD,wCAmBC","file":"BaseController.js","sourcesContent":["import {NextFunction, Request, Response} from \"express\";\r\nimport {NotFoundException} from \"../exceptions/NotFoundException\";\r\nimport {logger} from \"../../logger\";\r\nimport {HttpException} from \"../exceptions/HttpException\";\r\n\r\ndeclare type ControllerClass<T extends BaseController> = new (request: Request, response: Response) => T;\r\n\r\nconst controllerHandler: ProxyHandler<ControllerClass<BaseController>> = {\r\n    get(target: ControllerClass<BaseController>, p: PropertyKey, _: any): any {\r\n        return (req: Request, res: Response, next: NextFunction) => {\r\n            let controller = new target(req, res);\r\n            new Promise((resolve) => resolve(controller[p]())).catch(err => {\r\n                if (!(err instanceof HttpException)) {\r\n                    logger.error(err);\r\n                }\r\n                next(err);\r\n            });\r\n        }\r\n    }\r\n};\r\n\r\ntype RouteHandlerResolver<T extends BaseController> = {\r\n    readonly [P in keyof T]: (req: Request, res: Response) => any;\r\n}\r\n\r\nexport function controller<T extends BaseController>(kelas: ControllerClass<T>): RouteHandlerResolver<T> {\r\n    return new Proxy(kelas, controllerHandler) as any;\r\n}\r\n\r\nexport abstract class BaseController {\r\n    protected request: Request;\r\n    protected response: Response;\r\n\r\n    constructor(request: Request, response: Response) {\r\n        this.request = request;\r\n        this.response = response;\r\n    }\r\n\r\n    protected async resolveParam<T>(key: string, paramResolver: (key: string) => T, required: boolean = false) {\r\n        let data: T = undefined;\r\n        if (this.request.params.hasOwnProperty(key)) {\r\n            data = await paramResolver(this.request.params[key]);\r\n        }\r\n        if (required && (data === undefined || data === null)) {\r\n            throw new NotFoundException();\r\n        }\r\n        return data;\r\n    }\r\n}\r\n"]}